package com.example.composewidget.canvas

import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier

@Composable
fun BlendModeDemo(){
    Text(text = "Clear 清除 （删除源图像和目标图像，不留下任何内容）\n" +
            "Src 删除目标图像，只绘制源图像\n" +
            "Dst 删除源图像，只绘制目标图像\n" +
            "SrcOver 源图和目标图合成，源图在上\n" +
            "DstOver 目标图和源图合成，目标图在上\n" +
            "SrcIn 显示源图和目标图相交的部分，并且只显示源图像\n" +
            "DstIn 显示目标图和源图相交的部分，并且只显示目标图\n" +
            "SrcOut 显示源图像和目标图不相交的部分，并且只显示源图\n" +
            "DstOut 显示目标图和源图像不相交的部分，并且只显示目标图\n" +
            "SrcAtop  显示目标图，并且在相交的地方显示源图\n" +
            "DstAtop 显示源图，并在相交的地方显示目标图\n" +
            "Xor 显示源图和目标图，但相交的位置不显示（代码注释：对源图像和目标图像应用按位异或运算符。这就使得它们重叠的地方保持透明。）\n" +
            "Plus 对源映像和目标映像的组件求和。其中一个图像的像素中的透明度降低了该图像对相应输出像素的贡献，就好像该图像中该像素的颜色较暗一样\n" +
            "Modulate 将源图像和目标图像的颜色分量相乘。这只能产生相同或较深的颜色（乘以白色，1.0，结果不变；乘以黑色（0.0，结果为黑色）。合成两个不透明图像时，这与在投影仪上重叠两个透明胶片的效果类似。对于同样乘以alpha通道的变量，请考虑乘以。\n" +
            "Screen 将源图像和目标图像的分量的逆相乘，然后求逆结果。反转组件意味着完全饱和的通道（不透明白色）被视为值0.0，而通常被视为0.0（黑色，透明）的值被视为1.0。这基本上与调制混合模式相同，但是在乘法之前颜色值反转，结果在渲染之前反转回来。这只能产生相同或较浅的颜色（乘以黑色，1.0，结果不变；乘以白色（0.0，结果为白色）。类似地，在alpha通道中，它只能产生更不透明的颜色。这与两台投影仪同时在同一屏幕上显示图像的效果相似。\n" +
            "Overlay 将源图像和目标图像的分量相乘，然后调整它们以支持目标。具体来说，如果目标值较小，则将其与源值相乘，而如果源值较小，则将源值的倒数与目标值的倒数相乘，然后反转结果。反转组件意味着完全饱和的通道（不透明白色）被视为值0.0，而通常被视为0.0（黑色，透明）的值被视为1.0。\n" +
            "Darken 通过从每个颜色通道中选择最低值来合成源图像和目标图像。输出图像的不透明度的计算方法与SrcOver相同。\n" +
            "Lighten 通过从每个颜色通道中选择最高值来合成源图像和目标图像。输出图像的不透明度的计算方法与SrcOver相同。\n" +
            "ColorDodge 将目标除以源的倒数。反转组件意味着完全饱和的通道（不透明白色）被视为值0.0，而通常被视为0.0（黑色，透明）的值被视为1.0。注意这个BlendMode只能在androidapi级别29及以上使用\n" +
            "ColorBurn :将目标的倒数除以源的倒数，然后求结果的倒数。反转组件意味着完全饱和的通道（不透明白色）被视为值0.0，而通常被视为0.0（黑色，透明）的值被视为1.0。注意这个BlendMode只能在androidapi级别29及以上使用\n" +
            "Hardlight : 将源图像和目标图像的分量相乘，然后调整它们以有利于源图像。具体来说，如果源值较小，则将其与目标值相乘，而如果目标值较小，则将目标值的倒数与源值的倒数相乘，然后反转结果。反转组件意味着完全饱和的通道（不透明白色）被视为值0.0，而通常被视为0.0（黑色，透明）的值被视为1.0。注意这个BlendMode只能在androidapi级别29及以上使用\n" +
            "Softlight: 对于低于0.5的源值，使用ColorDodge；对于高于0.5的源值，使用ColorBurn。这会产生类似的效果，但比叠加效果更柔和。注意这个BlendMode只能在androidapi级别29及以上使用\n" +
            "Difference: 从每个通道的较大值中减去较小的值。合成黑没有效果；合成白色将反转其他图像的颜色。输出图像的不透明度的计算方法与SrcOver相同。注意这个BlendMode只能在androidapi级别29及以上使用这种影响类似于排斥，但更为严厉。\n" +
            "Exclusion: 从两个图像的总和中减去两个图像乘积的两倍。合成黑没有效果；合成白色将反转其他图像的颜色。输出图像的不透明度的计算方法与SrcOver相同。注意这个BlendMode只能在androidapi级别29及以上使用效果类似于差异，但更柔和。\n" +
            "Multiply: 将源图像和目标图像的分量相乘，包括alpha通道。这只能产生相同或较深的颜色（乘以白色，1.0，结果不变；乘以黑色（0.0，结果为黑色）。由于alpha通道也会相乘，因此一个图像中的完全透明像素（不透明度0.0）会导致输出中的完全透明像素。这与DstIn类似，但颜色组合在一起。\n" +
            "Hue: 获取源图像的色调，以及目标图像的饱和度和亮度。其效果是用源图像着色目标图像。输出图像的不透明度的计算方法与SrcOver相同。在源图像中完全透明的区域从目标图像获取其色调。注意这个BlendMode只能在androidapi级别29及以上使用\n" +
            "Saturation: 获取源图像的饱和度，以及目标图像的色调和亮度。输出图像的不透明度的计算方法与SrcOver相同。在源图像中完全透明的区域从目标图像获取其饱和度。注意这个BlendMode只能在androidapi级别29及以上使用\n" +
            "Color :获取源图像的色调和饱和度，以及目标图像的亮度。其效果是用源图像着色目标图像。输出图像的不透明度的计算方法与SrcOver相同。源图像中完全透明的区域从目标处获取其色调和饱和度。注意这个BlendMode只能在androidapi级别29及以上使用\n" +
            "Luminosity :获取源图像的亮度，以及目标图像的色调和饱和度。输出图像的不透明度的计算方法与SrcOver相同。在源图像中完全透明的区域从目标图像获取其亮度。注意这个BlendMode只能在androidapi级别29及以上使用\n" +
            ")" ,
            modifier = Modifier.verticalScroll(rememberScrollState())
            )


}